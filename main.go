package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

/*
type Thing interface {
	ast.Expr
	ast.FieldList
	String()
}

//each method is essentially a func type...
type FuncType struct {
	Params  *FieldList // (incoming) parameters; non-nil
	Results *FieldList // (outgoing) results; or nil
}

type FieldList struct {
	ast.FieldList
}


type FieldList struct {
   216  	Opening token.Pos // position of opening parenthesis/brace, if any
   217  	List    []*Field  // field list; or nil
   218  	Closing token.Pos // position of closing parenthesis/brace, if any
   219  }


type Field struct {
   193  	Doc     *CommentGroup // associated documentation; or nil
   194  	Names   []*Ident      // field/method/parameter names; or nil
   195  	Type    Expr          // field/method/parameter type
   196  	Tag     *BasicLit     // field tag; or nil
   197  	Comment *CommentGroup // line comments; or nil
	198  }




type (

	// A ParenExpr node represents a parenthesized expression.
	ParenExpr struct {
		X Thing // parenthesized expression
	}

	// A SelectorExpr node represents an expression followed by a selector.
	SelectorExpr struct {
		X   Thing  // expression
		Sel string // field selector
	}

	// An IndexExpr node represents an expression followed by an index.
	IndexExpr struct {
		X     Thing // expression
		Index Thing // index expression
	}

	// A SliceExpr node represents an expression followed by slice indices.
	SliceExpr struct {
		X      Thing // expression
		Low    Thing // begin of slice range; or nil
		High   Thing // end of slice range; or nil
		Max    Thing // maximum capacity of slice; or nil
		Slice3 bool  // true if 3-index slice (2 colons present)
	}

	// A TypeAssertExpr node represents an expression followed by a
	// type assertion.
	//
	TypeAssertExpr struct {
		X    Thing // expression
		Type Thing // asserted type; nil means type switch X.(type)
	}

	// A CallExpr node represents an expression followed by an argument list.
	CallExpr struct {
		Fun  Thing   // function expression
		Args []Thing // function arguments; or nil
	}

	// A StarExpr node represents an expression of the form "*" Expression.
	// Semantically it could be a unary "*" expression, or a pointer type.
	//
	StarExpr struct {
		X Thing // operand
	}

	// A UnaryExpr node represents a unary expression.
	// Unary "*" expressions are represented via StarExpr nodes.
	//
	UnaryExpr struct {
		X Thing // operand
	}

	// A BinaryExpr node represents a binary expression.
	BinaryExpr struct {
		X Thing // left operand
		Y Thing // right operand
	}

	// A KeyValueExpr node represents (key : value) pairs
	// in composite literals.
	//
	KeyValueExpr struct {
		Key   Thing
		Value Thing
	}
	// An ArrayType node represents an array or slice type.
	ArrayType struct {
		Len Thing // Ellipsis node for [...]T array types, nil for slice types
		Elt Thing // element type
	}

	// A StructType node represents a struct type.
	StructType struct {
		Fields     *FieldList // list of field declarations
		Incomplete bool       // true if (source) fields are missing in the Fields list
	}

	// Pointer types are represented via StarExpr nodes.

	// A FuncType node represents a function type.
	FuncType struct {
		Func    token.Pos  // position of "func" keyword (token.NoPos if there is no "func")
		Params  *FieldList // (incoming) parameters; non-nil
		Results *FieldList // (outgoing) results; or nil
	}

	// An InterfaceType node represents an interface type.
	InterfaceType struct {
		Interface  token.Pos  // position of "interface" keyword
		Methods    *FieldList // list of methods
		Incomplete bool       // true if (source) methods are missing in the Methods list
	}

	// A MapType node represents a map type.
	MapType struct {
		Map   token.Pos // position of "map" keyword
		Key   Thing
		Value Thing
	}

	// A ChanType node represents a channel type.
	ChanType struct {
		Begin token.Pos // position of "chan" keyword or "<-" (whichever comes first)
		Arrow token.Pos // position of "<-" (token.NoPos if there is no "<-")
		Dir   ChanDir   // channel direction
		Value Thing     // value type
	}
)*/

type Param struct {
	Names []string
	Type  string
}

type Method struct {
	Name    string
	Params  []Param
	Results []string
}

func TypeString(expr ast.Expr) string {

	switch expr.(type) {
	case *ast.Ident:
		return expr.(*ast.Ident).Name
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.ArrayType:
		return "[]" + TypeString(expr.(*ast.ArrayType).Elt)
	case *ast.StarExpr:
		return "*" + TypeString(expr.(*ast.StarExpr).X)
	case *ast.SelectorExpr:
		return TypeString(expr.(*ast.SelectorExpr).X) + "." + expr.(*ast.SelectorExpr).Sel.Name
	}

	return ""

}

func Names(idents []*ast.Ident) []string {

	names := []string{}
	for _, f := range idents {
		if f != nil {
			names = append(names, f.Name)
		}
	}
	return names
}

func GetMethodMap(f *ast.File, interfaceName string) (map[string]Method, error) {

	methodMap := make(map[string]Method)

	actual := &ast.Object{}
	found := false
	for _, obj := range f.Scope.Objects {
		if obj.Name == interfaceName && obj.Kind == ast.Typ {
			found = true
			actual = obj
		}
	}

	if !found {
		return methodMap, errors.New("interface not found")
	}

	//fmt.Printf("%s\n", actual.Name) //GoCloak

	//fmt.Printf("%T\n", actual.Decl) //*ast.TypeSpec

	d := actual.Decl

	//fmt.Printf("%s\n", d.(*ast.TypeSpec).Name) //GoCloak

	//fmt.Printf("%T\n", d.(*ast.TypeSpec).Type) //*ast.InterfaceType

	methods := (d.(*ast.TypeSpec).Type).(*ast.InterfaceType).Methods

	for _, m := range methods.List {
		// m is *ast.Field
		methodName := m.Names[0].Name

		switch m.Type.(type) {
		case *ast.FuncType:
			ft := m.Type.(*ast.FuncType)
			params := []Param{}
			results := []string{}

			if ft.Params != nil {
				if ft.Params.List != nil {
					for _, item := range ft.Params.List {
						params = append(params, Param{
							Names: Names(item.Names),
							Type:  TypeString(item.Type),
						})
					}
				}
			}

			if ft.Results != nil {
				if ft.Results.List != nil {
					for _, item := range ft.Results.List {
						results = append(results, TypeString(item.Type))
					}
				}
			}

			methodMap[methodName] = Method{
				Name:    methodName,
				Params:  params,
				Results: results,
			}
		}
	}

	return methodMap, nil
}

func main() {

	if len(os.Args) != 4 {
		fmt.Println("Usage ifcmp <README.md> <interface.go> <interface>")
		os.Exit(1)
	}

	//doc := os.Args[1]
	interfaceSource := os.Args[2]
	interfaceName := os.Args[3]

	fset := token.NewFileSet()

	f, err := parser.ParseFile(fset, interfaceSource, nil, 0)

	if err != nil {
		fmt.Printf("Error: %s\n", err.Error())
		os.Exit(1)
	}

	actualMethods, err := GetMethodMap(f, interfaceName)

	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	for _, v := range actualMethods {
		fmt.Println(v.String())
	}

	os.Exit(0)

}

func (m *Method) String() string {

	str := m.Name + "("

	params := []string{}

	for _, p := range m.Params {
		params = append(params, strings.Join(p.Names, ", ")+" "+p.Type)
	}

	str = str + strings.Join(params, ", ") + ")"

	if len(m.Results) > 0 {
		str = str + " "
		if len(m.Results) > 1 {
			str = str + "(" + strings.Join(m.Results, ", ") + ")"
		} else {
			str = str + m.Results[0]
		}
	}
	return str

}
